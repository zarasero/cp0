#include "AMateria.hpp"
#include "ICharacter.hpp"
#include "Character.hpp"
#include "Cure.hpp"
#include "Ice.hpp"
#include "MateriaSource.hpp"
#include "IMateriaSource.hpp"

#include <iostream>
#include "AMateria.hpp"
#include "Ice.hpp"
#include "Cure.hpp"
#include "Character.hpp"
#include "MateriaSource.hpp"

int main()
{
    // Создаем источник материй, реализующий интерфейс IMateriaSource
    IMateriaSource* src = new MateriaSource();

    // Обучаем источник двум материи: "Ice" (лед) и "Cure" (лечение)
    src->learnMateria(new Ice());  // Добавляет новый объект Ice в список доступных материй
    src->learnMateria(new Cure()); // Добавляет новый объект Cure

    // Создаем персонажа с именем "me"
    ICharacter* me = new Character("me");

    // Переменная для временного хранения материи
    AMateria* tmp;

    // Создаем материю типа "ice" из обученных шаблонов
    tmp = src->createMateria("ice");
    me->equip(tmp); // Персонаж "me" экипирует материю "ice"

    // Создаем материю типа "cure" из обученных шаблонов
    tmp = src->createMateria("cure");
    me->equip(tmp); // Персонаж "me" экипирует материю "cure"

    // Создаем второго персонажа с именем "bob"
    ICharacter* bob = new Character("bob");

    // Персонаж "me" использует материю из первого слота на "bob"
    me->use(0, *bob); // Вывод: "* shoots an ice bolt at bob *" (Ice)
    
    // Персонаж "me" использует материю из второго слота на "bob"
    me->use(1, *bob); // Вывод: "* heals bob's wounds *" (Cure)

    // Освобождаем динамически выделенную память
    delete bob;  // Удаляем персонажа "bob"
    delete me;   // Удаляем персонажа "me" и освобождаем его экипированные материи
    delete src;  // Удаляем источник материй

    return 0; // Завершаем программу
}

/*#include <iostream>
#include "AMateria.hpp"
#include "Ice.hpp"
#include "Cure.hpp"
#include "Character.hpp"
#include "MateriaSource.hpp"

int main()
{
    // ЭТАП 1: Создаем источник материй и обучаем его новым типам
    std::cout << "=== Создание источника материй и обучение его типам: Ice и Cure ===" << std::endl;
    IMateriaSource* materiaSource = new MateriaSource();  // Создаем источник материй

    materiaSource->learnMateria(new Ice());   // Обучаем материю типа Ice
    materiaSource->learnMateria(new Cure());  // Обучаем материю типа Cure
    std::cout << "Источник материй обучен двум типам: Ice и Cure" << std::endl;

    // ЭТАП 2: Создаем главного персонажа "me" и экипируем его материями
    std::cout << "\n=== Создание персонажа 'me' и экипировка его материями ===" << std::endl;
    ICharacter* me = new Character("me");  // Создаем персонажа с именем "me"

    AMateria* iceMateria = materiaSource->createMateria("ice");  // Создаем материю "ice" из шаблона
    AMateria* cureMateria = materiaSource->createMateria("cure"); // Создаем материю "cure" из шаблона

    if (iceMateria)
    {
        me->equip(iceMateria);  // Экипируем "me" материю "ice"
        std::cout << "Персонаж 'me' экипировал материю 'ice'" << std::endl;
    }
    if (cureMateria)
    {
        me->equip(cureMateria);  // Экипируем "me" материю "cure"
        std::cout << "Персонаж 'me' экипировал материю 'cure'" << std::endl;
    }

    // ЭТАП 3: Создаем второго персонажа "bob"
    std::cout << "\n=== Создание второго персонажа 'bob' ===" << std::endl;
    ICharacter* bob = new Character("bob");  // Создаем персонажа "bob"

    // ЭТАП 4: Персонаж "me" использует свои экипированные материи на "bob"
    std::cout << "\n=== Персонаж 'me' использует свои материи на 'bob' ===" << std::endl;
    me->use(0, *bob);  // Используем первую материю ("ice") на персонаже "bob"
    me->use(1, *bob);  // Используем вторую материю ("cure") на персонаже "bob"

    // ЭТАП 5: Удаляем созданные объекты и освобождаем память
    std::cout << "\n=== Освобождение памяти и завершение программы ===" << std::endl;
    delete bob;         // Удаляем персонажа "bob"
    delete me;          // Удаляем персонажа "me" и его экипировку
    delete materiaSource;  // Удаляем источник материй

    std::cout << "Программа завершена успешно!" << std::endl;
    return 0;
}
*/

/*Описание классов и их назначения:
1. AMateria (Абстрактный базовый класс)
Назначение:
Это абстрактный класс для материалов. Каждый материал имеет тип (например, «лёд» или «лекарство»). В классе определены виртуальные функции, которые должны переопределяться в производных классах.

Ключевые функции:

getType(): Возвращает тип материи.

clone(): Чисто виртуальная функция, которая возвращает новый объект соответствующего типа материи.

use(ICharacter& target): Виртуальная функция для использования материи на цели.

2. Ice (Производный класс от AMateria)
Назначение:
Класс, представляющий материю типа "Ice" (лед). Он переопределяет функции clone() и use().

Ключевые функции:

clone(): Создает новый объект Ice.

use(ICharacter& target): Выводит сообщение вида:

cpp
Копировать
Редактировать
std::cout << "* shoots an ice bolt at " << target.getName() << " *" << std::endl;
Это означает, что персонаж использует ледяную атаку на указанную цель.

3. Cure (Производный класс от AMateria)
Назначение:
Класс, представляющий материю типа "Cure" (лечение). Он также переопределяет функции clone() и use().

Ключевые функции:

clone(): Создает новый объект Cure.

use(ICharacter& target): Выводит сообщение:

cpp
Копировать
Редактировать
std::cout << "* heals " << target.getName() << "'s wounds *" << std::endl;
Это означает, что персонаж использует лечение на указанную цель.

4. ICharacter (Интерфейс)
Назначение:
Определяет интерфейс для персонажей. Содержит виртуальные функции, которые должны быть реализованы в классах-наследниках.

Ключевые функции:

getName(): Возвращает имя персонажа.

equip(AMateria* m): Экипирует персонажа материей.

unequip(int idx): Снимает материю из инвентаря.

use(int idx, ICharacter& target): Использует материю из указанного слота на цели.

5. Character (Класс, реализующий интерфейс ICharacter)
Назначение:
Класс персонажа, у которого есть имя и инвентарь для материалов (4 слота).

Ключевые функции:

Конструкторы и деструктор:
Инициализируют инвентарь пустыми значениями (NULL вместо nullptr). Копирующий конструктор и оператор присваивания клонируют экипированные материалы.

equip(AMateria* m): Экипирует материей первый свободный слот.

unequip(int idx): Снимает материю из указанного слота.

use(int idx, ICharacter& target): Использует материю из слота idx на цели target.

6. IMateriaSource (Интерфейс)
Назначение:
Определяет интерфейс для источников материй. Содержит чисто виртуальные функции:

Ключевые функции:

learnMateria(AMateria* m): Обучает источник новой материи.

createMateria(std::string const & type): Создает новую материю указанного типа (например, «лёд» или «лекарство»).

7. MateriaSource (Класс, реализующий интерфейс IMateriaSource)
Назначение:
Класс для хранения и создания материй. Может обучаться новым типам материй и создавать их по шаблонам.

Ключевые функции:

learnMateria(AMateria* m): Сохраняет шаблон материи в один из 4 слотов.

createMateria(std::string const & type): Проверяет тип материи и создаёт новый объект на основе шаблона, если он был обучен.

Как работает программа:
Создается объект MateriaSource, который может хранить и создавать материи.

В него добавляются шаблоны материалов: «Лед» и «Лечение».

Создаётся персонаж me и экипируется созданными материалами («лёд» и «лекарство»).

Создается второй персонаж bob.

Персонаж me использует свои материи на персонаже bob: сначала ледяная атака, затем лечение.

В конце освобождается вся динамически выделенная память.*/